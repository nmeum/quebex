{-# LANGUAGE TemplateHaskell #-}
-- The code generated by template-haskell does not have type signatures.
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Language.QBE.Simulator.Expression where

import Data.Bits (FiniteBits, finiteBitSize, shift, shiftR, (.&.), (.|.))
import Data.Int (Int16, Int64, Int8)
import Data.Word (Word16, Word32, Word64, Word8)
import GHC.Float (castDoubleToWord64, castFloatToWord32, castWord32ToFloat, castWord64ToDouble)
import Language.QBE.Simulator.Error (EvalError (InvaldSubWordExtension, TypingError))
import Language.QBE.Simulator.Generator (generateOperators)
import Language.QBE.Types qualified as QBE

data RegVal
  = VByte Word8
  | VHalf Word16
  | VWord Word32
  | VLong Word64
  | VSingle Float
  | VDouble Double
  deriving (Show, Eq)

toBytes :: RegVal -> [Word8]
toBytes val =
  let f w =
        map
          (\off -> fromIntegral $ shiftR w off .&. 0xff)
          (take (bytesize w) $ iterate (+ 8) 0)
   in case val of
        (VByte v) -> [v]
        (VHalf v) -> f v
        (VWord v) -> f v
        (VLong v) -> f v
        (VSingle v) -> toBytes (VWord $ castFloatToWord32 v)
        (VDouble v) -> toBytes (VLong $ castDoubleToWord64 v)
  where
    bytesize :: (FiniteBits a) => a -> Int
    bytesize v = finiteBitSize v `div` 8

fromBytes :: QBE.ExtType -> [Word8] -> Maybe RegVal
fromBytes ty lst =
  let f a =
        foldl
          (\x (byte, idx) -> (fromIntegral byte `shift` (idx * 8)) .|. x)
          0
          $ zip a [0 ..]
   in case (ty, lst) of
        (QBE.Byte, [byte]) -> Just $ VByte byte
        (QBE.HalfWord, bytes@[_, _]) -> Just (VHalf $ f bytes)
        (QBE.Base QBE.Word, bytes@[_, _, _, _]) -> Just (VWord $ f bytes)
        (QBE.Base QBE.Long, bytes@[_, _, _, _, _, _, _, _]) -> Just (VLong $ f bytes)
        (QBE.Base QBE.Single, bytes@[_, _, _, _]) ->
          Just (VSingle $ castWord32ToFloat (f bytes))
        (QBE.Base QBE.Double, bytes@[_, _, _, _, _, _, _, _]) ->
          Just (VDouble $ castWord64ToDouble (f bytes))
        _ -> Nothing

extSubWord :: QBE.SubWordType -> RegVal -> Either EvalError RegVal
extSubWord QBE.SignedByte (VByte b) = Right $ VLong (fromIntegral (fromIntegral (fromIntegral b :: Int8) :: Int64))
extSubWord QBE.UnsignedByte (VByte b) = Right $ VLong (fromIntegral b)
extSubWord QBE.SignedHalf (VHalf h) = Right $ VLong (fromIntegral (fromIntegral (fromIntegral h :: Int16) :: Int64))
extSubWord QBE.UnsignedHalf (VHalf h) = Right $ VLong (fromIntegral h)
extSubWord _ _ = Left InvaldSubWordExtension

subType :: QBE.BaseType -> RegVal -> Either EvalError RegVal
subType QBE.Word v@(VWord _) = Right v
subType QBE.Word (VLong l) = Right $ VWord (fromIntegral $ l .&. 0xffffffff)
subType QBE.Long v@(VLong _) = Right v
subType QBE.Single v@(VSingle _) = Right v
subType QBE.Double v@(VDouble _) = Right v
subType _ _ = Left TypingError

generateOperators
