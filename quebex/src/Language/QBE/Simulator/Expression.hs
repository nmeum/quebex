{-# LANGUAGE TemplateHaskell #-}
-- The code generated by template-haskell does not have type signatures.
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Language.QBE.Simulator.Expression where

import Data.Bits (FiniteBits, finiteBitSize, shift, shiftR, (.&.), (.|.))
import Data.Word (Word16, Word32, Word64, Word8)
import GHC.Float (castDoubleToWord64, castFloatToWord32, castWord32ToFloat, castWord64ToDouble)
import Language.QBE.Simulator.Error (EvalError (TypingError))
import Language.QBE.Simulator.Generator (generateOperators)
import Language.QBE.Types qualified as QBE

data RegVal
  = VByte Word8
  | VHalf Word16
  | VWord Word32
  | VLong Word64
  | VSingle Float
  | VDouble Double
  deriving (Show, Eq)

toBytes :: RegVal -> [Word8]
toBytes val =
  let f w =
        map
          (\off -> fromIntegral $ shiftR w off .&. 0xff)
          (take (bytesize w) $ iterate (+ 8) 0)
   in case val of
        (VByte v) -> [v]
        (VHalf v) -> f v
        (VWord v) -> f v
        (VLong v) -> f v
        (VSingle v) -> toBytes (VWord $ castFloatToWord32 v)
        (VDouble v) -> toBytes (VLong $ castDoubleToWord64 v)
  where
    bytesize :: (FiniteBits a) => a -> Int
    bytesize v = (finiteBitSize v) `div` 8

fromBytes :: QBE.ExtType -> [Word8] -> Maybe RegVal
fromBytes ty lst =
  let f a =
        foldl
          (\x (byte, idx) -> (fromIntegral byte `shift` (idx * 8)) .|. x)
          0
          $ zip a [0 ..]
   in case (ty, lst) of
        (QBE.Byte, [byte]) -> Just $ VByte byte
        (QBE.HalfWord, bytes@[_, _]) -> Just (VHalf $ f bytes)
        ((QBE.Base QBE.Word), bytes@[_, _, _, _]) -> Just (VWord $ f bytes)
        ((QBE.Base QBE.Long), bytes@[_, _, _, _, _, _, _, _]) -> Just (VLong $ f bytes)
        ((QBE.Base QBE.Single), bytes@[_, _, _, _]) ->
          Just $ (VSingle $ castWord32ToFloat (f bytes))
        ((QBE.Base QBE.Double), bytes@[_, _, _, _, _, _, _, _]) ->
          Just $ (VDouble $ castWord64ToDouble (f bytes))
        _ -> Nothing

assertType :: QBE.BaseType -> RegVal -> Either EvalError RegVal
assertType QBE.Word v@(VWord _) = Right v
assertType QBE.Long v@(VLong _) = Right v
assertType QBE.Single v@(VSingle _) = Right v
assertType QBE.Double v@(VDouble _) = Right v
assertType _ _ = Left TypingError

checkedEval ::
  QBE.BaseType ->
  (RegVal -> RegVal -> Either EvalError RegVal) ->
  RegVal ->
  RegVal ->
  Either EvalError RegVal
checkedEval retTy op lhs rhs = lhs `op` rhs >>= assertType retTy

generateOperators
