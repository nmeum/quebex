{-# LANGUAGE TemplateHaskell #-}
-- The code generated by template-haskell does not have type signatures.
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Language.QBE.Simulator.Expression where

import Data.Bits (FiniteBits, finiteBitSize, shiftR, (.&.))
import Data.Word (Word16, Word32, Word64, Word8)
import GHC.Float (castDoubleToWord64, castFloatToWord32)
import Language.QBE.Simulator.Error (EvalError (TypingError))
import Language.QBE.Simulator.Generator (generateOperators)
import Language.QBE.Types qualified as QBE

data RegVal
  = VByte Word8
  | VHalf Word16
  | VWord Word32
  | VLong Word64
  | VSingle Float
  | VDouble Double
  deriving (Show, Eq)

toBytes :: RegVal -> [Word8]
toBytes val =
  let f w =
        map
          (\off -> fromIntegral $ shiftR w off .&. 0xff)
          (take (bytesize w) $ iterate (+ 8) 0)
   in case val of
        (VByte v) -> [v]
        (VHalf v) -> f v
        (VWord v) -> f v
        (VLong v) -> f v
        (VSingle v) -> toBytes (VWord $ castFloatToWord32 v)
        (VDouble v) -> toBytes (VLong $ castDoubleToWord64 v)
  where
    bytesize :: (FiniteBits a) => a -> Int
    bytesize v = (finiteBitSize v) `div` 8

assertType :: QBE.BaseType -> RegVal -> Either EvalError RegVal
assertType QBE.Word v@(VWord _) = Right v
assertType QBE.Long v@(VLong _) = Right v
assertType QBE.Single v@(VSingle _) = Right v
assertType QBE.Double v@(VDouble _) = Right v
assertType _ _ = Left TypingError

checkedEval ::
  QBE.BaseType ->
  (RegVal -> RegVal -> Either EvalError RegVal) ->
  RegVal ->
  RegVal ->
  Either EvalError RegVal
checkedEval retTy op lhs rhs = lhs `op` rhs >>= assertType retTy

generateOperators
