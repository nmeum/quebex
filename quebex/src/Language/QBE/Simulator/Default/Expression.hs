{-# LANGUAGE TemplateHaskell #-}
-- The code generated by template-haskell does not have type signatures.
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Language.QBE.Simulator.Default.Expression where

import Data.Bits (FiniteBits, finiteBitSize, shift, shiftR, (.&.), (.|.))
import Data.Int (Int16, Int64, Int8)
import Data.Word (Word16, Word32, Word64, Word8)
import GHC.Float (castDoubleToWord64, castFloatToWord32, castWord32ToFloat, castWord64ToDouble)
import Language.QBE.Simulator.Default.Generator (generateOperators)
import Language.QBE.Simulator.Expression as E
import Language.QBE.Types qualified as QBE

-- TODO: Can we just wrap base type here?
-- TODO: Do not export the constructors
data RegVal
  = VByte Word8
  | VHalf Word16
  | VWord Word32
  | VLong Word64
  | VSingle Float
  | VDouble Double
  deriving (Show, Eq)

regToBytes :: RegVal -> [Word8]
regToBytes val =
  let f w =
        map
          (\off -> fromIntegral $ shiftR w off .&. 0xff)
          (take (bytesize w) $ iterate (+ 8) 0)
   in case val of
        (VByte v) -> [v]
        (VHalf v) -> f v
        (VWord v) -> f v
        (VLong v) -> f v
        (VSingle v) -> toBytes (VWord $ castFloatToWord32 v)
        (VDouble v) -> toBytes (VLong $ castDoubleToWord64 v)
  where
    bytesize :: (FiniteBits a) => a -> Int
    bytesize v = finiteBitSize v `div` 8

regFromBytes :: QBE.ExtType -> [Word8] -> Maybe RegVal
regFromBytes ty lst =
  let f a =
        foldl
          (\x (byte, idx) -> (fromIntegral byte `shift` (idx * 8)) .|. x)
          0
          $ zip a [0 ..]
   in case (ty, lst) of
        (QBE.Byte, [byte]) -> Just $ VByte byte
        (QBE.HalfWord, bytes@[_, _]) -> Just (VHalf $ f bytes)
        (QBE.Base QBE.Word, bytes@[_, _, _, _]) -> Just (VWord $ f bytes)
        (QBE.Base QBE.Long, bytes@[_, _, _, _, _, _, _, _]) -> Just (VLong $ f bytes)
        (QBE.Base QBE.Single, bytes@[_, _, _, _]) ->
          Just (VSingle $ castWord32ToFloat (f bytes))
        (QBE.Base QBE.Double, bytes@[_, _, _, _, _, _, _, _]) ->
          Just (VDouble $ castWord64ToDouble (f bytes))
        _ -> Nothing

instance Storable RegVal Word8 where
  toBytes = regToBytes
  fromBytes = regFromBytes

-- TODO: Insert the generated code directly into the instance declaration.
generateOperators

instance ValueRepr RegVal where
  fromLit QBE.Long n = VLong n
  fromLit QBE.Word n = VWord $ fromIntegral n
  fromLit QBE.Single n = VSingle $ fromIntegral n
  fromLit QBE.Double n = VDouble $ fromIntegral n

  fromAddress addr = VLong addr
  toAddress (VLong v) = Just v
  toAddress _ = Nothing

  fromFloat f = VSingle f
  fromDouble f = VDouble f

  extend QBE.SignedByte (VByte b) = Just $ VLong (fromIntegral (fromIntegral (fromIntegral b :: Int8) :: Int64))
  extend QBE.UnsignedByte (VByte b) = Just $ VLong (fromIntegral b)
  extend QBE.SignedHalf (VHalf h) = Just $ VLong (fromIntegral (fromIntegral (fromIntegral h :: Int16) :: Int64))
  extend QBE.UnsignedHalf (VHalf h) = Just $ VLong (fromIntegral h)
  extend _ _ = Nothing

  subType QBE.Word v@(VWord _) = Just v
  subType QBE.Word (VLong l) = Just $ VWord (fromIntegral $ l .&. 0xffffffff)
  subType QBE.Long v@(VLong _) = Just v
  subType QBE.Single v@(VSingle _) = Just v
  subType QBE.Double v@(VDouble _) = Just v
  subType _ _ = Nothing

  isZero (VByte 0) = True
  isZero (VHalf 0) = True
  isZero (VWord 0) = True
  isZero (VLong 0) = True
  isZero (VSingle 0) = True
  isZero (VDouble 0) = True
  isZero _ = False

  add = add'
  sub = sub'
