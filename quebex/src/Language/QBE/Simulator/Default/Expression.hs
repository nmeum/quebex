{-# LANGUAGE TemplateHaskell #-}
-- The code generated by template-haskell does not have type signatures.
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Language.QBE.Simulator.Default.Expression where

import Data.Functor ((<&>))
import Control.Monad (foldM)
import Data.Bits (FiniteBits, finiteBitSize, shift, shiftR, (.&.), (.|.))
import Data.Int (Int16, Int64, Int8)
import Data.Word (Word16, Word32, Word64, Word8)
import GHC.Float (castDoubleToWord64, castFloatToWord32, castWord32ToFloat, castWord64ToDouble)
import Language.QBE.Simulator.Default.Generator (generateOperators)
import Language.QBE.Simulator.Expression as E
import Language.QBE.Types qualified as QBE

-- TODO: Can we just wrap base type here?
-- TODO: Do not export the constructors
data RegVal
  = VByte Word8
  | VHalf Word16
  | VWord Word32
  | VLong Word64
  | VSingle Float
  | VDouble Double
  deriving (Show, Eq)

regToBytes :: RegVal -> [RegVal]
regToBytes val =
  let f w =
        map
          (\off -> VByte (fromIntegral $ shiftR w off .&. 0xff))
          (take (bytesize w) $ iterate (+ 8) 0)
   in case val of
        b@(VByte _) -> [b]
        (VHalf v) -> f v
        (VWord v) -> f v
        (VLong v) -> f v
        (VSingle v) -> toBytes (VWord $ castFloatToWord32 v)
        (VDouble v) -> toBytes (VLong $ castDoubleToWord64 v)
  where
    bytesize :: (FiniteBits a) => a -> Int
    bytesize v = finiteBitSize v `div` 8

regFromBytes :: QBE.ExtType -> [RegVal] -> Maybe RegVal
regFromBytes ty lst =
  let f a =
        foldM
          (\x (r, i) -> do
            byte <- getByte r
            pure $ (fromIntegral byte `shift` (i * 8)) .|. x)
          0
          $ zip a [0 ..]
   in case (ty, lst) of
        (QBE.Byte, [byte]) -> Just byte
        (QBE.HalfWord, bytes@[_, _]) -> f bytes <&> VHalf
        (QBE.Base QBE.Word, bytes@[_, _, _, _]) -> f bytes <&> VWord
        (QBE.Base QBE.Long, bytes@[_, _, _, _, _, _, _, _]) -> f bytes <&> VLong
        (QBE.Base QBE.Single, bytes@[_, _, _, _]) ->
          f bytes <&> VSingle . castWord32ToFloat
        (QBE.Base QBE.Double, bytes@[_, _, _, _, _, _, _, _]) ->
          f bytes <&> VDouble . castWord64ToDouble
        _ -> Nothing
  where
    getByte :: RegVal -> Maybe Word8
    getByte (VByte byte) = Just byte
    getByte _ = Nothing

instance Storable RegVal where
  toBytes = regToBytes
  fromBytes = regFromBytes

-- TODO: Insert the generated code directly into the instance declaration.
generateOperators

instance ValueRepr RegVal where
  fromLit QBE.Long n = VLong n
  fromLit QBE.Word n = VWord $ fromIntegral n
  fromLit QBE.Single n = VSingle $ fromIntegral n
  fromLit QBE.Double n = VDouble $ fromIntegral n

  fromFloat = VSingle
  fromDouble = VDouble

  fromAddress = VLong
  toAddress (VLong v) = Just v
  toAddress _ = Nothing

  extend QBE.SignedByte (VByte b) = Just $ VLong (fromIntegral (fromIntegral (fromIntegral b :: Int8) :: Int64))
  extend QBE.UnsignedByte (VByte b) = Just $ VLong (fromIntegral b)
  extend QBE.SignedHalf (VHalf h) = Just $ VLong (fromIntegral (fromIntegral (fromIntegral h :: Int16) :: Int64))
  extend QBE.UnsignedHalf (VHalf h) = Just $ VLong (fromIntegral h)
  extend _ _ = Nothing

  subType QBE.Word v@(VWord _) = Just v
  subType QBE.Word (VLong l) = Just $ VWord (fromIntegral $ l .&. 0xffffffff)
  subType QBE.Long v@(VLong _) = Just v
  subType QBE.Single v@(VSingle _) = Just v
  subType QBE.Double v@(VDouble _) = Just v
  subType _ _ = Nothing

  isZero (VByte 0) = True
  isZero (VHalf 0) = True
  isZero (VWord 0) = True
  isZero (VLong 0) = True
  isZero (VSingle 0) = True
  isZero (VDouble 0) = True
  isZero _ = False

  add = add'
  sub = sub'
