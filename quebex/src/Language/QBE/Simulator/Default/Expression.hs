-- SPDX-FileCopyrightText: 2025 SÃ¶ren Tempel <soeren+git@soeren-tempel.net>
--
-- SPDX-License-Identifier: GPL-3.0-only
{-# LANGUAGE TemplateHaskell #-}
-- The code generated by template-haskell does not have type signatures.
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Language.QBE.Simulator.Default.Expression where

import Control.Exception (assert)
import Data.Bits
  ( FiniteBits,
    finiteBitSize,
    shift,
    shiftR,
    unsafeShiftL,
    unsafeShiftR,
    xor,
    (.&.),
    (.|.),
  )
import Data.Int (Int16, Int32, Int64, Int8)
import Data.Word (Word16, Word32, Word64, Word8)
import GHC.Float (castDoubleToWord64, castFloatToWord32, castWord32ToFloat, castWord64ToDouble)
import Language.QBE.Simulator.Default.Generator (generateOperators)
import Language.QBE.Simulator.Expression qualified as E
import Language.QBE.Simulator.Memory qualified as MEM
import Language.QBE.Types qualified as QBE

-- TODO: Can we just wrap base type here?
-- TODO: Do not export the constructors
data RegVal
  = VWord Word32
  | VLong Word64
  | VSingle Float
  | VDouble Double
  deriving (Show, Eq)

fromBits :: Int -> Integer -> Maybe RegVal
fromBits 32 = Just . VWord . fromIntegral
fromBits 64 = Just . VLong . fromIntegral
fromBits _ = const Nothing

------------------------------------------------------------------------

shiftInstr ::
  (RegVal -> Word32 -> Maybe RegVal) ->
  RegVal ->
  RegVal ->
  Maybe RegVal
shiftInstr shiftOp val (VWord amount) = val `shiftOp` amount
shiftInstr _ _ _ = Nothing

toShiftAmount :: Word32 -> Word32 -> Int
toShiftAmount bitSize amount =
  -- From the QBE specification: "The shifting amount
  -- is taken modulo the size of the result type."
  let s = fromIntegral $ amount `mod` bitSize
   in assert (s > 0) s

shiftSar :: RegVal -> Word32 -> Maybe RegVal
shiftSar (VWord val) amount =
  (Just . VWord . fromIntegral) $
    (fromIntegral val :: Int32) `unsafeShiftR` (toShiftAmount 32 amount)
shiftSar (VLong val) amount =
  (Just . VLong . fromIntegral) $
    (fromIntegral val :: Int64) `unsafeShiftR` (toShiftAmount 64 amount)
shiftSar _ _ = Nothing

shiftShr :: RegVal -> Word32 -> Maybe RegVal
shiftShr (VWord val) amount =
  (Just . VWord) $ val `unsafeShiftR` (toShiftAmount 32 amount)
shiftShr (VLong val) amount =
  (Just . VLong) $ val `unsafeShiftR` (toShiftAmount 64 amount)
shiftShr _ _ = Nothing

shiftShl :: RegVal -> Word32 -> Maybe RegVal
shiftShl (VWord val) amount =
  (Just . VWord) $ val `unsafeShiftL` (toShiftAmount 32 amount)
shiftShl (VLong val) amount =
  (Just . VLong) $ val `unsafeShiftL` (toShiftAmount 64 amount)
shiftShl _ _ = Nothing

------------------------------------------------------------------------

regToBytes :: RegVal -> [Word8]
regToBytes val =
  let f w =
        map
          (\off -> fromIntegral $ shiftR w off .&. 0xff)
          (take (bytesize w) $ iterate (+ 8) 0)
   in case val of
        (VWord v) -> f v
        (VLong v) -> f v
        (VSingle v) -> MEM.toBytes (VWord $ castFloatToWord32 v)
        (VDouble v) -> MEM.toBytes (VLong $ castDoubleToWord64 v)
  where
    bytesize :: (FiniteBits a) => a -> Int
    bytesize v = finiteBitSize v `div` 8

regFromBytes :: QBE.LoadType -> [Word8] -> Maybe RegVal
regFromBytes ty lst =
  let f a =
        foldl
          (\acc (byte, idx) -> (fromIntegral byte `shift` (idx * 8)) .|. acc)
          0
          $ zip a [0 ..]
   in case (ty, lst) of
        (QBE.LSubWord QBE.UnsignedByte, [byte]) -> Just (VWord (fromIntegral byte))
        (QBE.LSubWord QBE.SignedByte, [byte]) -> Just (VWord $ fromIntegral (fromIntegral byte :: Int8))
        (QBE.LSubWord QBE.SignedHalf, bytes@[_, _]) -> Just (VWord $ fromIntegral (f bytes :: Int16))
        (QBE.LSubWord QBE.UnsignedHalf, bytes@[_, _]) -> Just (VWord $ fromIntegral (f bytes :: Word16))
        (QBE.LBase QBE.Word, bytes@[_, _, _, _]) -> Just (VWord $ f bytes)
        (QBE.LBase QBE.Long, bytes@[_, _, _, _, _, _, _, _]) -> Just (VLong $ f bytes)
        (QBE.LBase QBE.Single, bytes@[_, _, _, _]) ->
          Just (VSingle $ castWord32ToFloat (f bytes))
        (QBE.LBase QBE.Double, bytes@[_, _, _, _, _, _, _, _]) ->
          Just (VDouble $ castWord64ToDouble (f bytes))
        _ -> Nothing

instance MEM.Storable RegVal Word8 where
  toBytes = regToBytes
  fromBytes = regFromBytes

------------------------------------------------------------------------

-- TODO: Insert the generated code directly into the instance declaration.
generateOperators

-- We could also add support for unary operators to the generator. However,
-- presently there is only one unary operator so it isn't worth it.
neg' :: RegVal -> RegVal
neg' (VWord v) = VWord $ negate v
neg' (VLong v) = VLong $ negate v
neg' (VSingle v) = VSingle $ negate v
neg' (VDouble v) = VDouble $ negate v

-- This can't be easily auto generated because the operation differs
-- based on the type.
div' :: RegVal -> RegVal -> Maybe RegVal
div' (VWord lhs) (VWord rhs) =
  (Just . VWord . fromIntegral) $
    (fromIntegral lhs :: Int32) `div` (fromIntegral rhs :: Int32)
div' (VLong lhs) (VLong rhs) =
  (Just . VLong . fromIntegral) $
    (fromIntegral lhs :: Int64) `div` (fromIntegral rhs :: Int64)
div' (VSingle lhs) (VSingle rhs) = (Just . VSingle) $ lhs / rhs
div' (VDouble lhs) (VDouble rhs) = (Just . VDouble) $ lhs / rhs
div' _ _ = Nothing

instance E.ValueRepr RegVal where
  fromLit QBE.Long n = VLong n
  fromLit QBE.Word n = VWord $ fromIntegral n
  fromLit QBE.Single n = VSingle $ fromIntegral n
  fromLit QBE.Double n = VDouble $ fromIntegral n

  toWord64 (VWord v) = fromIntegral $ v
  toWord64 (VLong v) = v
  toWord64 (VSingle v) = fromIntegral $ castFloatToWord32 v
  toWord64 (VDouble v) = castDoubleToWord64 v

  fromFloat = VSingle
  fromDouble = VDouble

  wordToLong (QBE.SLSubWord QBE.SignedByte) (VWord b) = Just $ VLong (fromIntegral (fromIntegral b :: Int8))
  wordToLong (QBE.SLSubWord QBE.UnsignedByte) (VWord b) = Just $ VLong (fromIntegral b)
  wordToLong (QBE.SLSubWord QBE.SignedHalf) (VWord h) = Just $ VLong (fromIntegral (fromIntegral h :: Int16))
  wordToLong (QBE.SLSubWord QBE.UnsignedHalf) (VWord h) = Just $ VLong (fromIntegral h)
  wordToLong QBE.SLSignedWord (VWord w) = Just $ VLong (fromIntegral (fromIntegral w :: Int32))
  wordToLong QBE.SLUnsignedWord (VWord w) = Just $ VLong (fromIntegral w)
  wordToLong _ _ = Nothing

  subType QBE.Word v@(VWord _) = Just v
  subType QBE.Word (VLong l) = Just $ VWord (fromIntegral $ l .&. 0xffffffff)
  subType QBE.Long v@(VLong _) = Just v
  subType QBE.Single v@(VSingle _) = Just v
  subType QBE.Double v@(VDouble _) = Just v
  subType _ _ = Nothing

  add = add'
  sub = sub'
  mul = mul'
  div = div'
  urem = urem'
  srem = srem'
  udiv = udiv'
  or = or'
  xor = xor'
  and = and'

  neg = neg'

  sar = shiftInstr shiftSar
  shr = shiftInstr shiftShr
  shl = shiftInstr shiftShl

  -- TODO: Provide default implementations
  eq = eq'
  ne = ne'
  sle = sle'
  slt = slt'
  sge = sge'
  sgt = sgt'
  ule = ule'
  ult = ult'
  uge = uge'
  ugt = ugt'
